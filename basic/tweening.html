<!-- Exercise: making a click-based carousel for some object that tweens between each of its object. -->
<!--https://www.youtube.com/watch?v=VBLJ9hzW5fY&t=26s -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <style>
      html,
      body {
        border: 0;
        padding: 0;
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div><canvas id="canvas"></canvas></div>
  </body>

  <script>
    const tweener = {
      tween: function (beginPos, endPos, duration, tweenType, callback) {
        const beginningTime = performance.now();
        const diffX = endPos.x - beginPos.x;
        const diffY = endPos.y - beginPos.y;
        const initialPos = { ...beginPos };

        const func = this._tweenTypeResolver(
          tweenType,
          beginningTime,
          diffX,
          diffY,
          initialPos,
          duration,
          beginPos,
          callback
        );

        cancelAnimationFrame(func);

        func();
      },

      _tweenTypeResolver: (
        tweenType,
        beginningTime,
        diffX,
        diffY,
        initialPos,
        duration,
        beginPos,
        callback
      ) => {
        // https://www.desmos.com/calculator/lskstuoipd
        switch (tweenType) {
          case "linear":
            return function _beginLinearTween() {
              const currentDuration = performance.now() - beginningTime;
              if (currentDuration <= duration) {
                beginPos.x =
                  initialPos.x + (currentDuration / duration) * diffX;
                beginPos.y =
                  initialPos.y + (currentDuration / duration) * diffY;

                callback?.();

                requestAnimationFrame(_beginLinearTween);
              }
            };
          // basically 1 to the power of 2
          case "easeInQuad":
            return function _beginEaseInQuadTween() {
              const currentDuration = performance.now() - beginningTime;
              if (currentDuration <= duration) {
                const x = Math.pow(currentDuration / duration, 2);
                beginPos.x = initialPos.x + x * diffX;
                beginPos.y = initialPos.y + x * diffY;

                callback?.();

                requestAnimationFrame(_beginEaseInQuadTween);
              }
            };
          case "easeOutQuad":
            return function _beginEaseOutQuadTween() {
              const currentDuration = performance.now() - beginningTime;
              if (currentDuration <= duration) {
                const x = 1 - Math.pow(1 - currentDuration / duration, 2);
                beginPos.x = initialPos.x + x * diffX;
                beginPos.y = initialPos.y + x * diffY;

                callback?.();

                requestAnimationFrame(_beginEaseOutQuadTween);
              }
            };
          case "easeInOutQuad":
            return function _beginEaseInOutQuadTween() {
              const currentDuration = performance.now() - beginningTime;
              const x =
                (Math.sin(Math.PI * (currentDuration / duration - 0.5)) + 1) /
                2;
              if (currentDuration <= duration) {
                beginPos.x = initialPos.x + x * diffX;
                beginPos.y = initialPos.y + x * diffY;

                callback?.();

                requestAnimationFrame(_beginEaseInOutQuadTween);
              }
            };
          /**
           * animateBounce(beginPos, endPos, duration, angleFrom: someBeginningAngle, to: someEndAngle, onAnimationEnd: someCallback)
           */
          case "bounce1":
            return function _beginBounce1() {
              const currentDuration = performance.now() - beginningTime;
              const dx = currentDuration / duration;
              // For a sin function, we want to be able to just say,
              // I want the curve from pi to pi2 to be how my function
              // behaves und so was.
              // Example of the desired API
              // animateTween(beginPos, endPos, duration, angleFrom: 0, angleTo: Math.PI)
              // Should also check that the angleFrom is less than the angleTo, or have a strict mode where if true,
              // throws an error, else just convert by adding pi to both angleTo and angleFrom.

              //for now the beginning and the end angles are hard-coded, but eventually,
              // we'd want to be able to pass in the angleFrom and angleTo.

              // https://www.desmos.com/calculator/txhf7v994e

              // This, by the way, applies to all types of functions. You can put
              // any function as the baseFunc and give it the constraint, and our point
              // will always go from 0 to 1 based on the given curve of a function.

              const baseFunc = (x) => Math.cos(Math.atan(x)) ** 2 * Math.E;
              const begin = 0;
              const end = 35;
              // const begin = (3 * Math.PI) / 2;
              //const end = 8.2;
              //const baseFunc = (x) =>
              // Math.sin(2 * Math.sin(2 * Math.sin(Math.sin(Math.sin(x)))));
              const x =
                (baseFunc(dx * (end - begin) + begin) - baseFunc(begin)) /
                (baseFunc(end) - baseFunc(begin));
              if (currentDuration <= duration) {
                beginPos.x = initialPos.x + x * diffX;
                beginPos.y = initialPos.y + x * diffY;

                callback?.();

                requestAnimationFrame(_beginBounce1);
              }
            };
          default:
            throw new Error("Unknown tween type");
        }
      },
    };

    function lerp(start, end, amt) {
      return start + (end - start) * amt;
    }

    function fact(x) {
      if (!x) return 1;
      return x * fact(x - 1);
    }

    function drawCircle(x, y) {
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.fillStyle = "red";
      ctx.fill();
    }
  </script>
  <script>
    let canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    var width = window.innerWidth;
    var height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const circlePos = {
      x: width / 2,
      y: height / 2,
    };

    document.addEventListener("click", function (e) {
      const target = {
        x: e.clientX,
        y: e.clientY,
      };

      tweener.tween(circlePos, target, 500, "bounce1", () => {
        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

        drawCircle(circlePos.x, circlePos.y);
      });
    });

    drawCircle(circlePos.x, circlePos.y);
  </script>
</html>
