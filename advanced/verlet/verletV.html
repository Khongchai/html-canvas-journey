<!-- A chain using verlet integration -->

<!-- Known bug, but beyond the scope of this demo: clicking on one spot  -->
<!-- will sometimes cause the drag point to move. This is due to -->
<!-- prevX and prevY not being updated to match current mouse value -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <style>
      html,
      body {
        border: 0;
        padding: 0;
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body onload="draw();">
    <div><canvas id="canvas"></canvas></div>
  </body>
  <script>
    function drawPoint(ctx, { x, y, radius }) {
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    function hitTest(p, x, y) {
      const dx = p.x - x;
      const dy = p.y - y;
      return Math.sqrt(dx * dx + dy * dy) <= p.radius;
    }

    function moveDragPoint(dragPoint, mouse) {
      if (dragPoint.dragging) {
        dragPoint.x = mouse.x - mouse.offsetX;
        dragPoint.y = mouse.y - mouse.offsetY;
      }
      if (!dragPoint.dragging) {
        dragPoint.updateOnRelease();
      }
    }
  </script>
  <script>
    let canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    var width = window.innerWidth;
    var height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const mouse = {
      x: 0,
      y: 0,
      prevX: 0,
      prevY: 0,
      // For offsetting the starting point of the drag
      offsetX: 0,
      offsetY: 0,
    };

    const dragPoint = {
      x: width / 2,
      y: height / 2,
      radius: 20,
      dragging: false,
      vx: 0,
      vy: 0,
      friction: 0.9,
      updateOnRelease: function () {
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.x += this.vx;
        this.y += this.vy;

        if (!(0 <= this.x - this.radius) || !(this.x + this.radius <= width)) {
          this.vx *= -1;
        }
        if (!(0 < this.y - this.radius) || !(this.y + this.radius < height)) {
          this.vy *= -1;
        }
      },
    };

    const draw = () => {
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      drawPoint(ctx, dragPoint);
      moveDragPoint(dragPoint, mouse);

      requestAnimationFrame(draw);
    };
  </script>
  <script>
    window.addEventListener("mousedown", (e) => {
      const x = e.x;
      const y = e.y;
      if (hitTest(dragPoint, x, y)) {
        dragPoint.dragging = true;
        mouse.offsetX = x - dragPoint.x;
        mouse.offsetY = y - dragPoint.y;
      }
    });
    window.addEventListener("mousemove", (e) => {
      mouse.prevX = mouse.x;
      mouse.prevY = mouse.y;
      mouse.x = e.x;
      mouse.y = e.y;
    });
    window.addEventListener("mouseup", (e) => {
      if (dragPoint.dragging) {
        dragPoint.vx = (mouse.x - mouse.prevX) * 5;
        dragPoint.vy = (mouse.y - mouse.prevY) * 5;
      }
      dragPoint.dragging = false;
    });
  </script>
</html>
