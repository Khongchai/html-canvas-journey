<!-- Exercise: making a click-based carousel for some object that tweens between each of its object. -->
<!-- https://en.wikipedia.org/wiki/Smoothstep Smooth step for clamping -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <style>
      html,
      body {
        border: 0;
        padding: 0;
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div><canvas id="canvas"></canvas></div>
  </body>
  <script>
    const tweener = {
      /**
       * @param {{
        beginValue: {}, 
        endValue: {}, 
        propertiesToTween: string[],
        duration: number,
        tweenType: string,
        callback: VoidFunction
      }} firstNamedArgument
       */
      tween: function ({
        beginValue,
        endValue,
        propertiesToTween,
        duration,
        tweenType,
        callback,
      }) {
        // A map between the property and the difference corresponding to each of the properties.
        const differenceMap = {};
        propertiesToTween.forEach(
          (property) =>
            (differenceMap[property] =
              endValue[property] - beginValue[property])
        );

        const beginningTime = performance.now();
        const initialValue = Object.seal({ ...beginValue });

        const func = this._tweenTypeResolver(
          tweenType,
          beginningTime,
          differenceMap,
          initialValue,
          duration,
          beginValue,
          callback
        );

        cancelAnimationFrame(func);

        func();
      },

      _tweenTypeResolver: (
        tweenType,
        beginningTime,
        differenceMap,
        /**
         * This is the immutable object used as reference when we interpolate.
         */
        initialValue,
        duration,
        /**
         * This is the object to be interpolated to the next point.
         */
        beginValue,
        callback
      ) => {
        // https://www.desmos.com/calculator/lskstuoipd
        switch (tweenType) {
          case "linear":
            return function _beginLinearTween() {
              const currentDuration = performance.now() - beginningTime;
              if (currentDuration <= duration) {
                Object.keys(differenceMap).forEach((key) => {
                  beginValue[key] =
                    initialValue[key] +
                    (currentDuration / duration) * differenceMap[key];
                });

                callback?.();

                requestAnimationFrame(_beginLinearTween);
              }
            };
          // basically 1 to the power of 2
          case "easeInQuad":
            return function _beginEaseInQuadTween() {
              const currentDuration = performance.now() - beginningTime;
              if (currentDuration <= duration) {
                const x = Math.pow(currentDuration / duration, 2);
                Object.keys(differenceMap).forEach((key) => {
                  beginValue[key] = initialValue[key] + x * differenceMap[key];
                });

                callback?.();

                requestAnimationFrame(_beginEaseInQuadTween);
              }
            };
          case "easeOutQuad":
            return function _beginEaseOutQuadTween() {
              const currentDuration = performance.now() - beginningTime;
              if (currentDuration <= duration) {
                const x = 1 - Math.pow(1 - currentDuration / duration, 2);
                beginValue.x = initialValue.x + x * diffX;
                beginValue.y = initialValue.y + x * diffY;

                callback?.();

                requestAnimationFrame(_beginEaseOutQuadTween);
              }
            };
          case "easeInOutQuad":
            return function _beginEaseInOutQuadTween() {
              const currentDuration = performance.now() - beginningTime;
              const x =
                (Math.sin(Math.PI * (currentDuration / duration - 0.5)) + 1) /
                2;
              if (currentDuration <= duration) {
                beginValue.x = initialValue.x + x * diffX;
                beginValue.y = initialValue.y + x * diffY;

                callback?.();

                requestAnimationFrame(_beginEaseInOutQuadTween);
              }
            };
          /**
           * animateBounce(beginValue, endValue, duration, angleFrom: someBeginningAngle, to: someEndAngle, onAnimationEnd: someCallback)
           */
          case "bounce1":
            //Recommended duration:500
            return function _beginBounce1() {
              const currentDuration = performance.now() - beginningTime;
              const dx = currentDuration / duration;
              // For a sin function, we want to be able to just say,
              // I want the curve from pi to pi2 to be how my function
              // behaves und so was.
              // Example of the desired API
              // animateTween(beginValue, endValue, duration, angleFrom: 0, angleTo: Math.PI)
              // Should also check that the angleFrom is less than the angleTo, or have a strict mode where if true,
              // throws an error, else just convert by adding pi to both angleTo and angleFrom.

              //for now the beginning and the end angles are hard-coded, but eventually,
              // we'd want to be able to pass in the angleFrom and angleTo.

              // https://www.desmos.com/calculator/txhf7v994e

              // This, by the way, applies to all types of functions. You can put
              // any function as the baseFunc and give it the constraint, and our point
              // will always go from 0 to 1 based on the given curve of a function.

              //const baseFunc = (x) => Math.cos(Math.atan(x)) ** 2 * Math.E;
              //const baseFuncY = (x) => Math.cos(Math.atan(x)) ** 1 * Math.E;
              const baseFunc = (x) =>
                Math.pow(Math.E, -1.8 * x) *
                (Math.cos(3.8 * x + -1.8) + Math.sin(3.8 * x + -1.8));

              const baseFuncY = baseFunc;
              // const begin = 0;
              // const end = 35;

              const begin = 1.3;
              const end = 3.8;

              // const begin = (3 * Math.PI) / 2;
              //const end = 8.2;
              //const baseFunc = (x) =>
              // Math.sin(2 * Math.sin(2 * Math.sin(Math.sin(Math.sin(x)))));
              const x =
                (baseFunc(dx * (end - begin) + begin) - baseFunc(begin)) /
                (baseFunc(end) - baseFunc(begin));
              const y =
                (baseFuncY(dx * (end - begin) + begin) - baseFuncY(begin)) /
                (baseFuncY(end) - baseFuncY(begin));
              if (currentDuration <= duration) {
                beginValue.x = initialValue.x + x * diffX;
                beginValue.y = initialValue.y + y * diffY;

                callback?.();

                requestAnimationFrame(_beginBounce1);
              }
            };

          //Recommended duration: 3000
          case "bounce2":
            return function _beginBounce2() {
              const currentDuration = performance.now() - beginningTime;
              const dx = currentDuration / duration;
              const baseFunc = (x) =>
                Math.pow(Math.E, -1.8 * x) *
                (Math.cos(3.8 * x + -1.8) + Math.sin(3.8 * x + -1.8));

              const baseFuncY = baseFunc;
              const begin = 0;
              const end = 35;
              const x =
                (baseFunc(dx * (end - begin) + begin) - baseFunc(begin)) /
                (baseFunc(end) - baseFunc(begin));
              const y =
                (baseFuncY(dx * (end - begin) + begin) - baseFuncY(begin)) /
                (baseFuncY(end) - baseFuncY(begin));
              if (currentDuration <= duration) {
                beginValue.x = initialValue.x + x * diffX;
                beginValue.y = initialValue.y + y * diffY;

                callback?.();

                requestAnimationFrame(_beginBounce2);
              }
            };

          default:
            throw new Error("Unknown tween type");
        }
      },
    };

    function lerp(start, end, amt) {
      return start + (end - start) * amt;
    }

    function fact(x) {
      if (!x) return 1;
      return x * fact(x - 1);
    }

    function drawCircle(x, y) {
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.fillStyle = "red";
      ctx.fill();
    }
  </script>
  <script>
    let canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    var width = window.innerWidth;
    var height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const circlePos = {
      x: width / 2,
      y: height / 2,
    };

    document.addEventListener("click", function (e) {
      const target = {
        x: e.clientX,
        y: e.clientY,
      };

      // can even be more advanced, like each property has its own tweenType
      tweener.tween({
        beginValue: circlePos,
        endValue: target,
        propertiesToTween: ["x", "y"],
        duration: 300,
        tweenType: "easeInQuad",
        callback: () => {
          ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

          drawCircle(circlePos.x, circlePos.y);
        },
      });
    });

    drawCircle(circlePos.x, circlePos.y);
  </script>
</html>
