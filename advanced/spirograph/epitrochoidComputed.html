<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <style>
      html,
      body {
        border: 0;
        padding: 0;
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div><canvas id="canvas"></canvas></div>
  </body>
  <script>
    /**
     * Generate current point for epitrochoid of nested level n
     */
    function computedEpitrochoid(cycloids, theta, rodLength) {
      if (cycloids.length < 2) {
        throw new Error("Provide at least 2 cycloids");
      }

      const finalPoint = { x: 0, y: 0 };

      // Skip i = 0 because we don't need to iterate over the bounding circle
      for (let i = 1; i < cycloids.length; i++) {
        const parentCycloid = cycloids[i - 1];
        const thisCycloid = cycloids[i];
        const childCycloidRadius = thisCycloid.isOutsideOfParent
          ? thisCycloid.radius
          : -thisCycloid.radius;
        const isChildArcClockwise =
          thisCycloid.rotationDirection === "clockwise";

        // We ask the child it needs the parent to scale its theta.
        finalPoint.x +=
          (parentCycloid.radius + childCycloidRadius) *
          Math.cos(
            theta * thisCycloid.thetaScale - Math.PI * 0.5 * isChildArcClockwise
          );
        finalPoint.y +=
          (parentCycloid.radius + childCycloidRadius) *
          Math.sin(
            theta * thisCycloid.thetaScale + Math.PI * 0.5 * isChildArcClockwise
          );
      }

      return {
        x: finalPoint.x + rodLength * Math.cos(theta),
        y: finalPoint.y + rodLength * Math.sin(theta),
      };
    }
  </script>
  <script src="calcPoints.js"></script>
  <script>
    const enableDebug = true;

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const width = window.innerWidth;
    const height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    ctx.translate(width / 2, height / 2);
    ctx.fillRect(-width / 2, -height / 2, width, height);
    ctx.scale(0.5, 0.5);

    let previousPoints = null;

    let currentPoint = {
      x: 0,
      y: 0,
    };

    // The number of points required to complete 1 circle. This is chosen arbitrarily. Points calculations
    // will be based off of this.
    //
    // For now, circle of all sizes will have the same base step. This means that larger ones will have less
    // resolutions. This could be countered by {TODO}
    const baseStepsRequiredForACircle = 300;
    // Speed scale of 1 means the inner cycloid will cover the same distance regardless of its radius.
    // Controls for how far the points are distributed from one another
    // step = Math.PI * 2 / 60 means it only takes 60 + 1 points to draw a full circle of any radius.
    // + 1 because 1 we need to close the final loop.
    const step = (Math.PI * 2) / baseStepsRequiredForACircle;

    const betaScale = 1.7;
    const gammaScale = 1.16;
    const deltaScale = 1.3;

    const maxPoints = 100000;
    //TODO just make a simple multiple-number lcm that also accounts for the floating point precision error.
    // the actual lcm for the 3 scalars above = 266.22 Plugging this number as the lcmRatio will make everything work.
    const lcmRatio = multiLcm(betaScale, gammaScale, deltaScale);
    const baseRatio = betaScale * gammaScale * deltaScale;
    const points = Math.floor(
      Math.min(baseStepsRequiredForACircle * 50, maxPoints) + 1
    );

    const cycloids = [
      // Base Circle
      {
        radius: 300,
      },
      {
        radius: 100,
        rotationDirection: "counterclockwise",
        rodLengthScale: 0,
        thetaScale: betaScale,
        isOutsideOfParent: true,
      },
      {
        radius: 50,
        rotationDirection: "clockwise",
        rodLengthScale: 0,
        thetaScale: gammaScale,
        isOutsideOfParent: true,
      },
      {
        radius: 25,
        rotationDirection: "clockwise",
        rodLengthScale: 0,
        thetaScale: deltaScale,
        isOutsideOfParent: true,
      },
    ];
    const lastCycloid = cycloids[cycloids.length - 1];
    const rodLength = lastCycloid.radius * lastCycloid.rodLengthScale;
  </script>
  <script>
    let startingPoint;
    let endingPoint;
    let endingSameAsFirstCount = 0;

    const kindOfEqual = (num1, num2) =>
      parseFloat(num1.toFixed(4)) === parseFloat(num2.toFixed(4));

    const draw = () => {
      let theta = 0;

      for (let i = 0; i < points; i++) {
        theta += step;

        const newPoint = computedEpitrochoid(cycloids, theta, rodLength);

        // First point.
        if (!previousPoints) {
          previousPoints = newPoint;
          startingPoint = newPoint;
        } else {
          currentPoint = newPoint;
          ctx.beginPath();
          ctx.moveTo(previousPoints.x, previousPoints.y);
          ctx.lineTo(currentPoint.x, currentPoint.y);
          ctx.strokeStyle = "pink";
          ctx.stroke();

          if (
            enableDebug &&
            kindOfEqual(currentPoint.x, startingPoint.x) &&
            (currentPoint.y, startingPoint.y)
          ) {
            endingSameAsFirstCount++;
          }

          previousPoints = currentPoint;

          if (i === points - 1) {
            endingPoint = currentPoint;
          }
        }
      }

      if (enableDebug) {
        if (endingSameAsFirstCount > 1) {
          console.error("Debug: Path repeat count: " + endingSameAsFirstCount);
        }

        if (
          !kindOfEqual(startingPoint.x, endingPoint.x) ||
          !kindOfEqual(startingPoint.y, endingPoint.y)
        ) {
          console.error("Debug: the path is not closed properly");
          console.error("Debug: Starting point: ", startingPoint);
          console.error("Debug: Ending point: ", endingPoint);
        } else {
          console.info("Debug: Path closed properly.");
          console.info("Debug: Starting and ending points are the same point.");
        }
      }
    };

    draw();
  </script>
</html>
