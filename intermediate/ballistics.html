<!-- todo clamp angle and control position of gun without jumping -->
<!-- Exercise project: once all things are done, capture the shot cannon ball with your mouse -->
<!-- Collision detection and bounce physics -->
<!-- Collision detection against another inanimate object -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <style>
      canvas {
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
        border: none;
      }
    </style>
  </head>
  <body>
    <div>
      <canvas id="canvas" style="border: 1px solid black"></canvas>
    </div>
  </body>
  <script src="../classes/particle2.js"></script>
  <script src="../classes/vectors.js"></script>
  <script>
    let canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const width = window.innerWidth;
    const height = window.innerHeight;
    canvas.setAttribute("width", width);
    canvas.setAttribute("height", height);
    const gun = {
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      angle: -Math.PI / 4,
      length: 40,
      width: 16,
    };
    const cannonball = new Particle(gun.x, gun.y, 15, gun.angle, 0.2);
    //cannonball's circumference = 14, slightly smaller than the gun's diameter
    cannonball.radius = 7;
    let isShooting = true;
    const target = {
      x: 0,
      y: 0,
      radius: 0,
    };
    const currentMouse = {
      x: 0,
      y: 0,
    };
    const delayedMouse = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
    };

    const dx = 0.1;
    let x = 0;
    let rawForce = 0;

    function trackMouse() {
      //Use currentMouse as the spring bounce point
      delayedMouse.vx += (currentMouse.x - delayedMouse.x) * 0.4;
      delayedMouse.vy += (currentMouse.y - delayedMouse.y) * 0.4;
      delayedMouse.vx *= 0.7;
      delayedMouse.vy *= 0.7;
      delayedMouse.x += delayedMouse.vx;
      delayedMouse.y += delayedMouse.vy;

      const angle = Math.atan2(delayedMouse.y - gun.y, delayedMouse.x - gun.x);
      gun.angle = angle;
    }

    document.addEventListener("mousedown", onMouseDown);
    document.addEventListener("keydown", onKeyDown);

    function onMouseMove(e) {
      aimGun(e);
    }

    function onMouseDown(e) {
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);

      aimGun(e);
    }

    function onMouseUp(e) {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      aimGun(e);
    }

    function onKeyDown(e) {
      switch (e.keyCode) {
        case 32:
          if (!isShooting) {
            shoot();
          }
          break;

        default:
          break;
      }
    }

    function shoot() {
      //Set cannonball at the gun's end
      const force = remap(-1, 1, 2, 50, rawForce);
      cannonball.x = gun.x + Math.cos(gun.angle) * 40;
      cannonball.y = gun.y + Math.sin(gun.angle) * 40;
      cannonball.vx = Math.cos(gun.angle) * force;
      cannonball.vy = Math.sin(gun.angle) * force;

      ballFired();
    }

    function setTarget() {
      const posMin = 200;
      target.x = posMin + Math.random() * (width - posMin);
      target.y = posMin + Math.random() * (height - posMin);
      const radMin = 10;
      const radMax = 40;
      target.radius = radMin + Math.random() * (radMax - radMin);
    }

    function update() {
      if (!isShooting) {
        x += dx;
      }
      rawForce = Math.sin(x);

      if (isShooting) {
        checkTarget();
        cannonball.update();
      }
      draw();

      if (cannonball.y > height) {
        ballStopped();
      }
      requestAnimationFrame(update);
    }

    function checkTarget() {
      if (circlesColliding(cannonball, target)) {
        alert("You hit the target!");
        setTarget();
        ballStopped();
      }
    }

    function aimGun(e) {
      currentMouse.x = e.x;
      currentMouse.y = e.y;
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);

      ctx.fillStyle = "#ccc";
      ctx.fillRect(10, height - 10, 20, -100);

      ctx.fillStyle = "#666";
      ctx.fillRect(10, height - 10, 20, remap(-1, 1, 0, -100, rawForce));

      ctx.beginPath();
      ctx.arc(gun.x, gun.y, 24, 0, Math.PI * 2, false);
      ctx.fill();

      ctx.save();
      ctx.translate(gun.x, gun.y);
      ctx.rotate(gun.angle);
      ctx.fillRect(0, -8, gun.length, gun.width);
      ctx.restore();

      trackMouse();

      ctx.beginPath();
      ctx.arc(
        cannonball.x,
        cannonball.y,
        cannonball.radius,
        0,
        Math.PI * 2,
        false
      );
      ctx.fill();

      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2, false);
      ctx.fill();
    }

    function ballFired() {
      isShooting = true;
    }

    function ballStopped() {
      cannonball.y = gun.y;
      cannonball.x = gun.x;
      isShooting = false;
    }

    function remap(iMin, iMax, oMin, oMax, weight) {
      return lerp(oMin, oMax, inverseLerp(iMin, iMax, weight));
    }

    function lerp(start, end, amt) {
      return (1 - amt) * start + amt * end;
    }

    function inverseLerp(min, max, value) {
      return (value - min) / (max - min);
    }

    function circlesColliding(c1, c2) {
      const dx = c1.x - c2.x;
      const dy = c1.y - c2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return c1.radius + c2.radius >= distance;
    }

    setTarget();
    update();
  </script>
</html>
